## Parsing from an IO
Suppose now instead you want to parse a FASTA file of _arbitrary size_, expecting that it may run into the tens of gigabytes.
In that case, it's not feasible to parse from a byte buffer, and you must instead parse from an IO object.
Automa enables this by hooking into `TranscodingStreams.jl`.
This package provides a wrapper IO of the type `TranscodingStream`.
Importantly, these streams buffer their input data.
Automa is thus able to operate directly on the input buffers of `TranscodingStream` objects.

Unfortunately, this _significantly_ complicates things compared to parsing from a simple buffer.
The main problem is that, when reading from a buffered stream, the byte array visible from `Automa` is only a small slice of the total input data.
Worse, when the end of the stream is reached, data from the buffer is flushed, i.e. removed from the stream.
To handle this, Automa must reach deep into the implementation details of `TranscodingStreams`, and also break some of its own abstractions.
It's not pretty, but it's what we have.

Practically speaking, parsing from IO is done with the function `Automa.generate_reader`.
Despite its name, this function is NOT directly used to generate objects like `FASTA.Reader`.
Instead, this function produces Julia code (an `Expr` object) that, when evaluated, defines a function that can execute an Automa machine on an IO.
Let me show the code in pseudocode generated by `generate_reader` format first:

```
function { function name }(stream::TranscodingStream, { args... })
    { init code }

    @label EXECUTE_MACHINE

    is_eof = eof(stream)
    p = current_buffer_position
    p_end = final_buffer_position

    load new data into buffer, if any
    is_eof = eof(stream)
    execute normal automa parsing of the buffer
    flush any used up data from the buffer

    { loop code }

    if machine errored or reached EOF
        { return code }
    end
    @goto EXECUTE_MACHINE
end
```

The content marked `{ function name }`, `{ args... }`, `{ init code }`, `{ loop code }` and `{ return code }` are arguments to `Automa.generate_reader`.
By providing these, the user can customize the generated function further.

The main difference is the label/GOTO pair `EXECUTE MACHINE`, which causes Automa to repeatedly load data into the buffer, execute the machine, then flush used data from the buffer, then execute the machine, and so on, until interrupted.

Importantly, `p` and `p_end` is continuously updated in this loop, as flushing the data may move data around such that these changes.
Furthermore, `is_eof` is set to whether the stream has reached EOF.

## Example use
Let's show the simplest possible example of such a function.
We have a `Machine` (which, recall, is a compiled regex) called `fasta_machine`, and we want to make a function that returns `true` if a given `IO` contain data that conforms to the regex format specified by the `Machine`.

To do this, we simply need to call `generate_reader`, where the `{ return code }` is a check if `iszero(cs)`, meaning if the machine exited at a proper exit state.
Then, we need to evaluate the code created by `generate_reader` in order to define the function `validate_fasta`

```julia
return_code = :(iszero(cs))
eval(generate_reader(:validate_fasta, fasta_machine; returncode=return_code)) 
```

The generated function `validate_fasta` has the function signature:
`validate_fasta(stream::TranscodingStream)`

Remember that the generated function must take a `TranscodingStream`.
If our input IO is not a `TranscodingStream`, we can wrap it in the relatively lightweight `NoopStream`, which, as the name suggests, does nothing to the data:

```julia
julia> using TranscodingStreams

julia> io = NoopStream(IOBuffer(">a\nTAG\nTA\n>bac\nG\n"));

julia> validate_fasta(io)
true

julia> validate_fasta(NoopStream(IOBuffer("random data")))
false
```

## Parsing records using `generate_reader`
There are a few more subtleties related to the `generate_reader` function.
Suppose we instead want to create a function that reads a single FASTA record from an IO.
In this case, it's no good that the function created from `generate_reader` will loop until the IO reaches EOF - we need to find a way to stop it.
We do this by stopping the machine execution at certain points - for example, if the machine has created a FASTA record.

We will reuse our `Seq` struct and our `Machine` from the "parsing from a buffer" section of this tutorial:
```julia
struct Seq
    name::String
    seq::String
end

machine = let
    header = re"[a-z]+"
    header.actions[:enter] = [:mark_position]
    header.actions[:exit] = [:header]
    
    seqline = re"[ACGT]+"
    seqline.actions[:enter] = [:mark_position]
    seqline.actions[:exit] = [:seqline]
    
    record = re">" * header * re"\n" * RE.rep1(seqline * re"\n")
    record.actions[:exit] = [:record]
    compile(RE.rep(record))
end
```

We will also mostly re-use the actions, with the minor difference that when creating a `Seq`, instead of pushing onto a vector of sequences,
we will use the pseudo-macro `@escape`, which will escape out of the machine:

```julia
actions = Dict{Symbol, Expr}(
    :mark_position => :(pos = p),
    :header => :(header = String(data[pos:p-1])),
    :seqline => :(append!(buffer, data[pos:p-1])),

    # Only this action is different from before!
    :record => quote
        seq = Seq(header, String(buffer))
        found_sequence = true
        p -= 1
        @escape
    end
)
```

`@escape` is not actually a real macro, but Automa's compiler will parse it and replace it with the proper code to break out of the executing machine,
regardless of what kind of machine we have.

Let's see how I use `generate_reader`, then I will explain each part:

```julia
generate_reader(
    :read_record,
    machine;
    actions=actions,
    initcode=quote
        buffer = UInt8[]
        pos = 0
        found_sequence = false
        header = ""
        local seq
    end,
    loopcode=quote
        found_sequence && @goto __return__
    end,
    returncode=quote
        if cs < 0
            error("Malformed FASTA file")
        elseif found_sequence
            return seq
        else
            return nothing
        end
    end
) |> eval
```

In the `:record`, action, a few new things happen.
* First, I set the flag `found_sequence = true`.
  In the loop code, I look for this flag to signal that the function should return.
  I could just return the sequence directly, but then I would skip a bunch of the code generated by `generate_reader` which sets the buffer state correctly.
  Instead, in the _loop code_, which executes after the buffer has been flushed, I check for this flag, and goes to `__return__` if necessary.
  I could also just return directly in the loopcode, but I prefer only having one place to retun from the function.
* I use `@escape` to break out of the machine, i.e. stop machine execution
* Finally, I decrement `p`. This is because, the first record ends when the IO reads the second `>` symbol.
  If I then were to read another record from the same IO, I would have already read the `>` symbol.
  I need to reset `p` by 1, so the `>` is also read on the next call to `read_record`.

I can use the function like this:

```julia
julia> io = NoopStream(IOBuffer(">a\nT\n>tag\nGAGA\nTATA\n"));

julia> read_record(io)
Seq("a", "T")

julia> read_record(io)
Seq("tag", "GAGATATA")

julia> read_record(io)

julia>
```

## Preserving data by marking the buffer
There is a problem with the implementation above: The following code in my actions dict:

```julia
header = String(data[pos:p-1])
```

Creates `header` by accessing the data buffer.
However, when reading an IO, how can I know that the data hasn't shifted around in the buffer between when I defined `pos`?
For example, suppose we have a short buffer of only 8 bytes, and the following FASTA file: `>abcdefghijkl\nA`.
Then, the buffer is first filled with `>abcdefg`.
When entering the header, I execute the action `:mark_position` at `p = 2`, so `pos = 2`.
But now, when I reach the end of the header, the used data in the buffer has been flushed, and the data is now:
`hijkl\nA`, and `p = 14`.
I then try to access `data[2:13]`, which is out of bounds!

Luckily, the buffers of `TranscodingStreams` allow us to "mark" a position to save it.
The buffer will not discard the marked position, or any position after the marked position.
Inside the function generated by `generate_reader`, we can use the zero-argument macro `@mark`, which marks the position `p`.
The macro `@markpos` can then be used to get the marked position, even if its value has been moved by the buffer.
This works because the mark is stored inside the `TranscodingStream` buffer, and the buffer makes sure to update the mark if the content moves.
Hence, we can re-write the actions:

```julia
actions = Dict{Symbol, Expr}(
    :mark_position => :(@mark),
    :header => :(header = String(data[@markpos():p-1])),
    :seqline => :(append!(buffer, data[@markpos():p-1])),

    [:record action omitted...]
)
```

In our example above with the small 8-byte buffer, this is what would happen:
First, the buffer contains the first 8 bytes.
When `p = 2`, the mark is set, and the second byte is marked::

```
content: >abcdefg
mark:     ^
p = 2     ^
```

Then, when `p = 9` the buffer is exhausted, the used data is removed, BUT, the mark stays, so only 2 bytes are moved.
Since two bytes were moved, `p` is decremented to `7`
The buffer now looks like this:

```
content: abcdefgh
mark:    ^
p = 7          ^
```

Only 2 bytes was cleared, so when `p = 9`, the buffer will be exhausted again.
This time, no data can be cleared, so instead, the buffer is resized to fit more data:

```
content: abcdefghijkl\nA
mark:    ^
p = 9            ^
```

And so everything works.
